database - organized collection  of storing data...

DBMS -> Database Management System --> communicate users and db

types of DBMS : hierarchial, relational, network, distributed(multiple physical locations), object oriented db, cloud, graph db..

login -> email and pwd
messages -> email and messages
account settings -> different from person to person


SQL and Non-SqL data.. Open Source

SQL(Structured Query Language) : Databases and Tables -> rows and columns : RDBMS -> structured
  - MS Server, MySQL, SQL, postgresql, oracle etc
NoSQL DB  : JSON -> Collections and Documents -> not structured, non-relational
  - MongoDB, DynamoDB, Cassandra, MariaDB, IBM DB2 etc

create, read/fetch/get/retrieve, update, delete : Basic operations.. 

Installed MySQL Installer : https://dev.mysql.com/downloads/installer/

under this -> workbench, shell(optional), server

Create a database : create database schools(database Name);
Backup your tables : Backup db tablename to disk filepath.. or right click on a table and select export wizard
Drop you db : drop database user_management(database Name);

Show your databases : show databases


Create a table in particular db :


Create table dbName.tableName ( 
--(here my table name is student)
	StudentId int,
    FirstName nvarchar(255),
    LastName nvarchar(255),
    isCertified boolean
)

Create another table from existing table, select required columns:

create table new_table_name AS
 Select StudentId, FirstName
 From student 
 -- where StudentId is not null 

 Where condition is optional

show tables; -> will give you all the existing tables in your DB

 Delete a table : 

 		drop table tableName : Table itself is deleted
 		truncate table tableName : Only data(values of rows and columns) will be deleted , table structure will not be effected.
    Delete : 
		delete from student; //delete all the rows..
		delete from student where StudentId = 1; // deletes for rows which satisfy where condition	 

Alter : 

	Adding a column : 
	
	Alter table student
	Add grades int; 

	Delete a column :

	Alter table student
	drop column grades ; or drop grades;

	Rename a column:

		alter table student
		rename column grades to marks;	

	Add at particular place :

	Alter table student
	Add  marks int after LastName; or before isCertified

	changing the column datatype :

	Alter table student
	modify column marks varchar(10);

Insert Data into a table :

Insert into student (StudentId,FirstName,LastName,marks,isCertified)
values (1, "John", "Doe", 75, true);	


Update :

	 update student set isCertified = false // applies for whole table
	 update student set isCertified = true where StudentId = 2; // updates for rows which satisfy where condition
	 update student set isCertified = true, FirstName = "John" where StudentId = 2; update multiple columns

Delete : 
	delete from student; //delete all the rows..
	delete from student where StudentId = 1; // deletes for rows which satisfy where condition	 


Constraints: specify some rules for data in a table.. column level and table level

	Not Null : A column can't have a null value
	unique : emailId/phoneNumber/aadhar number
  Primary Key -> Unique Key and it can't be null. A table will have only one primary key
  Foreign Key --> Kind of creates links between two tables.. One table can have any number of foreign keys

      Table Student -> StudentId is your primary key... Other columns : FirstName, LastName, 
 		  Marks, isCertified --> into this table TeacherId as a foreign Key
			Table Teacher -> TeacherId is your primary key.. Other columns : TeacherName, 
			Experience, Expertise, salary 

			1 (TeacherID , Kamala -> 1 to 45 student IDs

	Check : ensure your column has some data in it.	
	Default : sets a default value to the column, if no value is specified
	create index : for reading and creation operations, this will be quick operations..	
	Auto increment : automatically adds and inserts the value , if not specified

	Syntax for constraints :

	Create table Teacher ( 
	TeacherId AutoIncrement int Not null unique,
	StudentId int not null,
    TeacherName nvarchar(255),
    experience int,
    salary int Default (10000),
    
    Primary Key (TeacherId),
    foreign key (StudentId) references student(StudentId),
    Check (experience > 2)

)

Adding constraints to an existing table:

Alter table student
modify column StudentId int not null;

Alter table student
modify column StudentId int auto_increment;


Like : 

select * from student where FirstName like '%John%'

select * from student where LastName like 'P_t__'

select * from student where LastName like 'Pe%' and LastName like '%er'
select * from student where LastName like 'Pe%' or LastName like '%er'
select * from student where LastName like 'Peter' 

Between:

select * from student where StudentId between 3 and 6;
select * from student where StudentId not between 3 and 6;

select * from student where StudentId in (1,4,5)
select * from student where StudentId not in (1,4,5)


Operations : < , <= , > , >= , = , !=

select * from student where studentId <= 4


Bring multiple specific columns and you can do a temporary change of column names (Alias):

select FirstName, LastName as SurName from student where StudentId not between 3 and 6;


Count of rows:

select count(*) from student;

Distinct : Unique values in rows

select count(distinct(FirstName)) from student;


Extract from left or right in a column and bring the value


select right(LastName, 2) as ExtractedLastName from student;

select left(LastName, 2) as ExtractedLastName from student;

Order By:

Ascending order: Default;

select * from student order by isCertified 
    - incase of integer -> 0 to n
    - incase of alphabet -> dictonary order

Descending Order :

select * from student order by FirstName Desc


Top or limit:


select  * from student limit 3
select  * from student where isCertified = 1 limit 3;
select  * from student order by FirstName Desc limit 3;

Aggregate Functions:


select min(Salary) from teacher;
select max(Salary) from teacher;
select sum(Salary) from teacher;
select avg(Salary) from teacher;

For teacher Kamala, I need both teacher details and students under her..

bring data from my both tables where teacherId of student should be equal to the teacher Id of my teacher


Join.. Inner, Left , Right , Outer join(cross/cartesian), self


select stu.*, tea.TeacherName from student stu
Inner join teacher tea on tea.TeacherId = stu.TeacherId


select stu.*, tea.TeacherName from student stu
join teacher tea on tea.StudentId = stu.StudentId


union and union all;

select TeacherId from student  union select TeacherName from teacher 
select TeacherId from student  union all select TeacherName from teacher 


select TeacherId from student  union all select TeacherName from teacher order by TeacherId

Group By:

select count(FirstName), isCertified from student group by isCertified;

offset: skip certian rows, typically used with limit

select * from student limit 3 offset 2;

array -> [1,2,3,4,5,...10]

search number 10.

traditionally, looping and then seearch.. O(n) -> 10 times

binary search -> sorted -> divide into two parts -> [1 to 5] & [6 to 10] -> one time
[6 to 10] -> two parts, [6,7] [8, 9, 10] -> compare 10 with these parts -> divide -> 9,10 --> 4 times --> O(logn)

create a index --> to speed up your read queries.. it follows binary search algorithm..

create index indexName on tableName (columnName)

create INDEX idx_firstName
ON student (FirstName)

to see all indices on table:

show indexes from student;

Delete an index:

alter table tableName
drop index index_Name;

Alter table student
drop index idx_lastName;

select FirstName from student ; -> you get in a order, dictionary order

clustered index (physical data) and non-clustered index (address of your physical data.. memory location..)


cons: writing will be time consuming process.. distributed db..

masted db.. no indices.. write ops... create/update/delete
slave db.. all indices.. read ops..

after particular period of time, both dbs will be synced..


coalesce : check for nulls and give proper response

select StudentId, coalesce(FirstName, LastName) as FullName from student ;


Inner Query:

select * from student where TeacherId not in (select TeacherId from Teacher) ;

SP : Stored Procedure:

CREATE PROCEDURE `SelectAllStudents` ()
BEGIN
Select * from student;
END

Inside sql work bench:

USE `schools`;
DROP procedure IF EXISTS `SelectAllStudents`;

DELIMITER $$
USE `schools`$$
CREATE PROCEDURE `SelectAllStudents` ()
BEGIN
Select * from student;
END$$

DELIMITER ;

Call SelectAllStudents();



Connectivity from Java to DB:

n methods ->n class ->n package -> application --> built and put it on a jar..
just like .exe for application, .jar..


https://dev.mysql.com/downloads/connector/j/ --> Add this jar to your build path

        String query = "select * from student";

        Connection connection = DriverManager.getConnection("jdbc:mysql://localhost/schools?user=root&password=Password!123");

        PreparedStatement preparedStatement = connection.prepareStatement(query);
        ResultSet resultSet = preparedStatement.executeQuery();

        while (resultSet.next()) {
            System.out.println(resultSet.getInt(1) + " " + resultSet.getString(3) + " " + 
                    resultSet.getBoolean(6));
        }

    }

Maven: Build tool, add dependency in pom.xml.. Connecting from maven project..



MONGO DB:

No sql.. 

employee, manager, admin, director.. if you need particular from a particular table.. join using your FK or PK..

data -> JSON.. 
{
	"id" : 1,
	"name" : "Oswald",
	"eventsAttended" : ["catering", "swimming"]
	"isCertified" : true
}

{
	"id" : 1,
	"name" : "roy"
}

tables --> Collections
rows/column -> Documents
column -> keys/fields

Download mongoDb : community server: https://www.mongodb.com/try/download/shell

https://robomongo.org/ or mongo compass


To start your mongo server, open cmd and type mongosh

default port: 27017

show dbs; -> gives you all existing database

use schools -> switch to schools db

use schoolsNew -> if you don't have a db.. it will create a db.. orElse it uses existing db

under same db -> db.dropDatabase();

schoolsNew> db.dropDataBase();

cls -> clears your screen

schools> db.createCollection("students")
show collections; -> existing collections will be displayed

Delete a collection:

 db.collectionName.drop(); -->  db.grades.drop();

 CRUD Operations: create, read, update, delete..

 Create -- Insert:

db.students.insertOne({ name : "Peter", age : 15, dateOfJoining: Date(), certificates : 1})

schools> db.students.insertMany([{ name : "Parker", age : 14, dateOfJoining: Date(), certificates : 2} , { name : "John", age : 17, certificates : 3}])

Read : Find/search/get/retrieve:

db.students.find() -> List of all records
db.students.findOne() -> brings you top/first record
db.students.find({name: 'Parker'}) -> where name = Parker..
db.students.find( {name: 'Parker', age : 14}) --> where name = Parker and age =14
db.students.find({}, {name: 'Parker'}) --> brings you all data along with particular field(s)
db.students.find({}, {name: 'Parker', age : 14, _id:0}) --> when 0 -> it will not bring those ids (exclude ids)
 {name: 'Parker', age : 15, _id:1}) -> when 1, it brings id.. (include ids)

 0 or 1 is applicable only for id.. not on other fields

 db.students.find({}, {name: 'Parker', age : 15}) -> bring you all data

Update:

db.students.updateOne({certificates:2}, {$set: {age:16}})
db.students.updateOne({certificates:2}, {$set:{name: "Jack", age: 15, lastModifiedDate:Date()}}) --> updates multiple fields, you can add a new field to an existing document, here we added Date field
db.students.updateOne({certificates:4}, {$set:{name: "Jill", age: 15, Date:Date()}}, {upsert:true}) --> inserts data into your document if you don't have existing data with the where condition..
db.students.updateMany({}, {$inc : {certificates : 1}}) --> for many records, increment operates adds a digit specified
db.students.updateMany({name:"Parker"},{$currentDate:{LastModifiedDate:true, ModifiedDate:{$type:'date'}}}) 
 db.students.updateMany({name:"Rama"},{$currentDate:{LastModifiedDate:true, ModifiedDate:{$type:'date'}}}, {upsert:true})

- $rename : renames the field
- $set : sets the value for fields, upsert:true
- $unset : remove the field

Array Elements Operations:

$addToSet:

db.students.updateMany({}, {$addToSet: {marks: {$each : [67, 98]}}}) -> based on where condition... it will add items
db.students.updateMany({}, {$pop:{marks: -1}}) //remove the 0th or first Index
db.students.updateMany({}, {$pop:{marks: 1}}) //remove the last index

  Add again --> db.students.updateMany({}, {$addToSet: {marks: {$each : [77, 99]}}}) --> add at the last just like java

db.students.updateMany({}, {$push: {marks: 83}}) --> elements get added at the last Index
 db.students.updateMany({},{$push:{marks:{$each:[88], $position:1}}}) -> at a particular index
 db.students.updateOne( { name:"Peter" }, { $pull: { marks: { $gt: 90 } } } ) 
 db.students.updateOne( { name:"Peter" }, { $pullAll: { marks: [88] } } )		


 Delete:

db.students.deleteOne({name:"Parker"}) -> deletes first record , where condition satifies


 db.students.deleteOne({}) -> The top or first document will be deleted
 db.students.deleteMany({}) -> deletes all documents in a collection
 db.students.deleteMany({name:"Parker"})

 Exporting Data and Importing data through compass...


 db.students.find({product_price : {$eq : 690}}), gt, gte, lt,lte,ne

 db.students.find({arrayofProducts : {$in : ["apple", "banana"]}})
 db.students.find({arrayofProducts : {$nin : ["apple", "banana"]}})

 ExecutionStatastics : Stats -

 db.students.find({certificates:3}).explain("executionStats") , docsExamined : 27..

 Index:

 db.students.createIndex({'certificates':1})

 db.students.find({certificates:3}).explain("executionStats") -> docs examined are 1..

 db.students.dropIndex("certificates_1") -> delete an index

 Types of Indexes:

		 Single Field Index (one field), 
		 Compund Index (two or more fields : 1,-1), 
		 multikey index (array), 
		 text indexes (string objects), 
		 wildcard index(few fields vary from document to document .$**), 
		 hashed index ( :hashed), 
		 geospatial indexes (geojson/legacy keyco-ordinates pairs, 2d sphere)


Aggregate Functions	/ PipeLines / Operations	 :

db.students.aggregate([{$match:{product_price: {$gt: 474}}}]) -> match all the documents where price is greater than 474

db.students.aggregate([{$match:{product_price: {$gt: 474}}}, {$count: "totalQuantity"}]) --> gives the count of query in individual declared key

db.students.aggregate([{$match:{product_price:474}}]) -> price is 474

db.students.aggregate([{$match: {product_price : {$gt: 600}}},{$group : {_id:"$product_material"}}]) 

db.students.aggregate([{$limit:n}]) -> bring top n documents

db.students.aggregate(([{$match: {product_price : {$gt: 70}}},{$group : {_id:"$product_material", totalPrice:{$sum: {$multiply:["$product_price", "$quantity"]}}}}, {$sort: {totalPrice: -1}}, {$limit:5}, {$project: {"_id":0}}]))

Join : self join or other collections join.. $lookup:


db.students.aggregate([{$lookup:{from: "schools", localField: "_id", foreignField:"_id", as:"Details of the Product"}}])

  {
    $lookup: {
      from: "schools",  // the collection to join with
      localField: "_id",         // the field from the input documents
      foreignField: "_id",       // the field from the documents of the "from" collection
      as: "Details of the Product"  // the alias for the joined data
    }

Mapping you collection toArray() -> 

store your query in a variable; var, const keyword in JS.. we have them in mongo

var allStudentsCollection = db.find().toArray();
allStudentsCollection.length -> length of your collection

 var priceOperation = db.students.find().map(function(e){return e.product_price * 2}).toArray();

 priceOperation -> result.. NaN means it's not a number

 schools> priceOperation
[
  NaN, NaN, 1310, 1822, 1380, 984,
   66, 948, 1000,  156,   56, 168,
   52, 178,   74,  108,   86,  94,
   72, 176,   92,   72,  180, 198,
  190,  94,   40
]

For loop in mongo:

 for(const myElement of priceOperation){print ("Product price is: " + myElement/2)}
 

 Validate your schema:

 db.createCollection("students", {
   validator: {
      $jsonSchema: {
         bsonType: "object",
         required: ["name", "year", "mobileNumber"],
         properties: {
            name: {
               bsonType: "string",
               description: "Must be a string and this is a required field"
            },
            year: {
               bsonType: "int",
               minimum: 2015,
               maximum: 3000,
               description: "Must be an integer. This is the date of birth year and should be > 2014 and < 3000"
            },
            mobileNumber: {
               bsonType: "double"
            },
            address: {
               bsonType: "string"
            }
         }
      }
   }, validationLevel:"error"
})

Connect Mongo to Java:

dependency :    

<!-- https://mvnrepository.com/artifact/org.mongodb/mongodb-driver-sync -->
    <dependency>
      <groupId>org.mongodb</groupId>
      <artifactId>mongodb-driver-sync</artifactId>
      <version>5.0.1</version>
    </dependency>

Class:

   		MongoClient mongoClient = MongoClients.create("mongodb://localhost:27017");
        MongoDatabase database = mongoClient.getDatabase("schools");
        MongoCollection<Document> mongoCollection = database.getCollection("students");

        FindIterable<Document> documents = mongoCollection.find();

        documents.forEach(System.out::println); 


MultiThreading In Java:

thread -> main.. set of rules or instructions

extends Thread class or implements Runnable interface-> Callable interface

thread.start, sleep, interrrupt, set priority and yield, dead lock, synchronized keyword, join, pause, wait, etc

React JS: alternative of JSP -> we will in servlets

JSP -> Java Server Pages --> java plus html tags

React -> like your jsp

Vanila JS -> to create  simple h1

   		const app = document.getElementById("app");
      const header = document.createElement("h1");
      const headerContent = document.createTextNode("Menu from script");

      header.appendChild(headerContent);
      app.appendChild(header);

facebook developed react.js      

React -> state and properties.. just like your extends classes and implements interface

Spring Framework:

backend (server/application)-> which runs 24*7..

request (UI) -> backend (processes request) -> give you response..
 
Java -> framework called Spring..

main frames ., JSP (Java Server Page) + Servlets + JSF.. Java Enterprise Edition i.e., JAVA EE... difficult maintain & code..

pros:

less code
configurations defined and managed by spring
reduce boiler plate code -> you can have very simple logical changes or no change at all.. instead of redefining you can use the existing code

throughout the app, this peiece of program repeats..

public mathematicalOperations(anyVariable , balance){

	**Bank Account**

	// debit -> you have subtract numbers
	// credits to your acc -> add your numbers
	// some interest credited to savings acc -> 12% of your balance should be credited..
	// loans
}



n number of coaches.. for different sports and for single sport you can have different coaches
        
objects are tightly coupled with your classes.. every obj is dependent on particular class

LOOSE COUPLING -> declare an interface 


Spring IOC and Spring DI --> Inversion of Control and Dependency Injection..

object managed by spring -> bean

IOC : Beans.. Bean LifeCycle.. object creation to destruction..
DI -> inject dependencies of other classes for your respective beans..

created a  application conext.xml ->

pom.xml -> added spring-context depdendency

        ClassPathXmlApplicationContext context = new
                ClassPathXmlApplicationContext("applicationContext.xml");

        Coach cricketCoach = context.getBean("myCricketCoach", Coach.class);
        System.out.println(cricketCoach.getDailyWorkOut());

        Coach footBallCoach = context.getBean("myFootBallCoach", Coach.class);
        System.out.println(footBallCoach.getDailyWorkOut());

  cricketCoach/footBallCoach --> wish service (happy wish service)      

  	-- constructor
  	-- getter and setter
  

  spring: 
  
   --	constructor Injection : <constructor-arg ref="myWish"> </constructor-arg>
   -- getter and setter injection :         <property name="wishService" ref="myWish"/>
   -- set your properties   <property name="email" value="${email}"/>, 
       <context:property-placeholder location="application.properties"/>

scope : singleton by default., prototype:
    <bean id="myCricketCoach" class="com.spring.demo.CricketCoach" scope="prototype">

Bean init, processing bean , destrcution: Bean Life cycle


    <bean id="myCricketCoach" class="com.spring.demo.CricketCoach" 
          init-method="startUpMethod" destroy-method="destroyMethod">

          singleton -> started -> beans created -> destroyed
          prototype -> Started bean and Started bean -> beans created

To read/create beans in different packages ->
    <context:component-scan base-package="com.spring"/>

@Autowired : 
	DI : 
	 constructor level -> mandatory fields
	 setter level -> not frequently used fields.. optional fields
	 field/class level -> least priority..

@Component
@Scope
@PostConstruct
@PreDestroy
@Configuration
@ComponentScan
@PropertySource
@Qualifier-> two beans, to give preference you use this : constructor level, field level, setter level
or @Primary

third party jars:

    @Bean
    public WishService wishService(){
        return  new HappyWishService();
    }

@Value("${email}") // to read properties from your application.properties
private String email;


27/04 -> spring mvc and spring boot, sample rest api creation

spring mvc :

java -> spring -> mvc : model, view, controller design pattern

Request -> Dispatcher Servlet -> a class used to map the request to correct source controlle/model/views..

	configuration manually(server)
	specify dependencies separately
	MVC & front ctrls
	doesn't batch

spring boot: built on top of spring mvc

spring app + internal http server(tomcat/jetty) -xml config -> boot application: controller, service, repository, model, entity layers -> CRUD application -> creating, reading, updating, deleting operations on an object or class
	REST APIS
	dependencies will be wrapped as a single unit
	db layer, service layer, ctrl layer, integration layer
	supports batch


@SpringBootApplication -> boot application === @Configuration + @EnableAutoConfiguration + @ComponentScan

default -> tomcat server.. can you any other server? yes, in pom.xml you can mention the dependency of a server and bring that particular sever..

lombok  -> @Data, @AllArgsConstructor, @NoArgsConstructor

logging -> info, debug, error level


    private static Log log = LogFactory.getLog(Student.class);

    public static void main(String[] args) {
        Student student = new Student();
        student.setId(1);
        log.info("Tomcat is running and you student id is : " + student.getId()); //set log levels
    }

API -> application program interface -> connect your request (UI) & response (backend)
	  types based on sharing: private, public, composite, partner

API -> endpoint.. address to your code/api
	types of API : based on architecture - SOAP(XML)., REST(JSON,XML, text, html etc), Graph QL-2005 very recent(JSON)
								 based on request -> POST, GET, UPDATE(PUT/PATCH), DELETE

request -> application -> controller(define only req and response) -> service(business logic) -> repository(db calls)	

http://localhost:8080/guvi/zen/next-steps

/next-steps -> end-point
guvi/zen -> req mapping
8080 -> port
http/https : protocol
localhost : domain means where your app is running
localhost:8080 -> base URL/URI

Status code along with your API: 	gives information about your response fetched from API
Universal Standardised Codes:

Informational responses (100 – 199)
Successful responses (200 – 299)
Redirection messages (300 – 399)
Client error responses (400 – 499)
Server error responses (500 – 599)

modify your response by creating a custom class.. ResponseHandler

ResponseEntity
@RestController : @Contoller(@Component for bean creation) + @ResponseBody
@PostMapping
@GetMapping
@PutMapping
@DeleteMapping
@PathVariable -> to read the parameter in url eg: http://localhost:8080/students/getStudent/2 (2 is path variable)
@RequestBody -> to read complete object body

postman -> tool

28/04/24:

create API, delete API, update API, search with query parameters url?id=1&firstName=Harry

	- Path variable -{pathParam}
	- query param - @RequestParam

Swagger: API documentation, you can test your APIS..	

	app.properties or app.yaml -> load confoguration to you applications...

	swagger2 & swagger3

Swagger 3:

<!-- https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-starter-webmvc-ui -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.5.0</version>
</dependency>

@OpenAPIDefinition -> customise your swagger look
customising swagger at appication,controller, dto/schema level.

Spring Hibernate  & JPA

JPA -> Java persistence API ---> library -> hibernarte under JPA

Mappings -> relation btwn tables..

	one to one : one person has one govt id proof number(aadhar)
	one to many : one person has many proofs(pan, aadhar, ration, gas etc)
	many to one : many apples for a single person
	many to many : apple.. many apples and many people will eat apples

persontable ----> Order table

one person can have multiple orders -> P-O : One to many
O -> P : Many to One mapping., many orders can be assosciated with a single person..

@Entitiy
@Table
@Id
@column
@Generatedvalue
@OneToMany
@ManytoOne

04/05/2024 : spring JPA

added app.props, added entity, added repo -> extends JPARepository, add service interface and impl class

	controller -> service -> repository

	spring is capable enough to check duplicate email entries, create tables if table doesn't exist

	internally this uses hibernate

	aop -> aspect oriented programming with spring -> introduce new interfaces and define new programming structure 	  	usage : logging framework/db translations

	IOC : management of dependencies vs AOP -> cross-cutting concerns (improves performance) 

Assignment :    Finish implementing get all users, get single user,update,delete APIs

Spring data mongodb:

dto/entity -> data transfer object -> ctrlr -> service -> repo
@Document(collection = "product")

locking -> I am adding data(10 new fields), you are retrieving data(10 new fields won't be displayed..) 10 new fields should be displayed -> acquire lock on db so that add ops will be successfully implemented and then your fetch ops will be started..same record/collection/table, if you are editing parallely -> lock will deny your request, my record is saved -> lock will be released -> you can do your opss

Locking -> prevent parallel access of data..

Strategies for locking -> Optimistic and Pessimistic locking

Optimistic -> will check that transaction is not modified, if you have any modification.. rollback locking

pessimistic -> on memory level, you acquire a  lock on object.. isolation levels.. transaction level lock.. roll back if lock is for specific time

ACID principles, isolation levels at service layer (@Transactional(Isolation.READ_COMMITTED))., select for update to acquire a lock

https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking

microservices, spring boot exception handling, actuator, validation of schemas -> next topics

05/04/24 :: Microservices: Spring Cloud

monolithic -> single service apps...

microservices -> amazon -> product search module, payment module

[search], [payment] -> single application..
	[search], [payment] ; [search], [payment]; [search], [payment] :: when you do search your payment is also loaded..
search -> separately & payment separately

 pros : easy to scale, maintain
 				if one service fails it doesn't effect other services
 				each MS(microservice) has unique function
 				easy to test/debug
 				diff technologies for diff services

 microservice communication :: search and product, different application can use different technology to implement a module

communication : search speak with payment & vice versa..
				sync : search service will wait for the response of payment service
				async : search service won't wait for the response of payment service and these are parallel operations 				
apps -> both sql & no-sql dbs., or two types of sql dbs.. for eg: one service can run on sql db other service can run on MS SQL db or Oracle db or postgres sql db etc..
 	api -> ms1 -> sql, ms2 -> mongo, ... ms10 -> oracle


search -> 8080 port : java app -> set of X API's
payment -> runs on 9090 port : node.js application -> set of Y API's

n ms run on n diff ports -> track -> API gateway
 
 client (server) -> ms1, ms2 , ms3..

 						API gateway --> Euereka Server (register your ports here)

 			ms1 , ms2,  ms3 ..... msn -> fwds the request			


 ms1 gives the result of two numbers added (a+b = 5)

 ms2 is sending this a+b=5 to ms3...

If ms2 fails, ms3 can't get a+b=5.. also ms1 can't give a+b =5 to ms2... 		
 		To avoid this circuit breaker pattern..


Configuration of ms -> app.props -> config server.. 		

one ms can have many instances->copy of your ms.. to track your instances * services register.. track for discovery..

distributed tracing -> track your api calls & see what's happening inside it..

cloud bus ->  kind of message broker -> applies all updated changes(app.properties) to the application 

spring features + All the above + few additional features : Spring CLOUD :  https://spring.io/projects/spring-cloud

Spring Mapping ::::

	ctrlr -> USER(dbEntity) -> service -> repository -> user is passed through all the layers
	ctrlr -> dto(only fields, no db schema) -> service (send dto from ctrl and map this dto to entity) send entity -> repository

	either by manually mapping dto to entity and vice versa or using a Model Mapper

18/05/24:

communication btwn microservices :
		
		- Rest Template
		- Spring Cloud Openfeign libarary.
		- webclient library

SERVICE REGISTRY ::::::::: Discovery Server
	
	server ---> registers different clients		on app level : @EnableEurekaServer
		Add dependency of spring-cloud-starter-netflix-eureka-server in service registry and spring-cloud-starter-netflix-eureka-client for clients	
		in clients : eureka.instance.client.serverUrl.defaultZone=http://localhost:8761/Euereka

Mvn commands...
	
	mvn clean -> deletes target folder
	mvn install -> run all profiles of maven app
	validate -> validates your app and check if eveything is fine..
	compile -> check for compilation errors & generate a target
	test -> check junit tests
	package -> all above steps..


Instances -> copy of same appliacation running at different places...
	port 1 : 8080 -> 5 req
	port 2 : 8082 -> 5 req	


API Gateway : depending on user req, we will route the req to the ms.	

		from spring initializr download the project & add in your workspace..

		At app level --> @EnableEurekaClient


	app.props : 
		
		eureka.instance.client.serverUrl.defaultZone=http://localhost:8761/eureka
		management.endpoints.web.exposure.include=*

		spring.cloud.gateway.routes[0].id=DEPARTMENT-SERVICE
		spring.cloud.gateway.routes[0].uri=lb://DEPARTMENT-SERVICE
		spring.cloud.gateway.routes[0].predicates[0]=Path=/api/departments/**

		spring.cloud.gateway.routes[1].id=EMPLOYEE-SERVICE
		spring.cloud.gateway.routes[1].uri=lb://EMPLOYEE-SERVICE
		spring.cloud.gateway.routes[1].predicates[0]=Path=/api/employees/**	



API GATE WAY registered ---> Service Registry <----	microservices as well registered....	

	Route your req from api gateway to a particular ms...


Config Server :
	created a project with config-server dependency & in mservices add config-client dependency
	created git hub repo and put the ms properties here
	In config server : app. props make changes
	app -> @EnableConfigServer
	service-registry -> add reference of config server
	for actuator -> add actuator dependency


First Start servers -> config/eureka server then start instances api-gateway & ms

If some changes in configuration i.e., properties change we have to restart your app, instead of that we have a message broker:
To avoid the above scenario we have Spring Bus...

Message Controller -> in all ms

	@RefreshScope  // to enable dynamic(change) config properties reload

Tools to broadcast msg -> rabbitmq, kafka, apache mq..

	spring-cloud-starter-bus-amqp --> add dependency in ms

RabbitMQ : install docker desktop:

	in cmd : docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.13-management	

19/05/24 :

distributed tracing : log4j /sl4j...
	: data dog, relic --> paid tools
	: zipkin/micrometer -> open source tools
		- add 4 dependencies in api gateway, all micro services
		- app.props where ever you added the dependencies
		- run in docker command : docker run -d -p 9411:9411 openzipkin/zipkin


emp service depends on -> dept service... & dept is down ===> 500 internal error		
Circuit breaker -> add dependency , app.props
	https://resilience4j.readme.io/docs/circuitbreaker -> fault isolation

	retry -> transient faults

*********************************************

Exception handling & Validation in boot, Actuator conecepts.
	
	error handling : providing proper info to the user, why the request failed..
		 - email already exists exception, fName/lName can't be null, resource not found exception..

Validation in spring:
	- use @Valid on req object
	- use @Nonull or non empty
	- ref : https://www.bezkoder.com/spring-boot-validate-request-body/		 

25/05/24:

web app architecture --> user layers for security -> backend (logic & db connection ) -> response and show to user through UI..

Servlets : java EE + jsp (java server pages)


graph  ql -> 

req -> only req fields -> response..
 	intro bt fb... for insta and db.. only when you scroll you get info.. you don't have to load all data..
 		: no need to send alll fields -> time saving, memory saving and response is quick..

Spring Security :::	

AUTHENTICATION : verifying user.. emp vs non-emp

AUTHORIZATION : providing access to user -> admin, user..

TODO Management : To do tasks..

	- built a post task and get all tasks API..
	- basic spring security
	- basic security by overriding default username & pwd -> app.properties..
	
	- config level -> provide username  & pwd, authorization

		: authentication -> 401
		: authorization -> 403 forbidden

	- hasRole, hasAnyRole at config level or at method/class level -> @PreAuthorize


user_roles :

	users	  				roles
	 1(john)        1(admin)
	 2(harry)       1(admin)
	 3(peter)       2(user)	


AuthenticationFilter -> AuthenticationManager -> ProviderManager -> AuthenticationProvider -> DaoAuthenticationProvider -> UserDetailsService

	--> through db, we saw how we hit our api's
	-- in postman we are giving details -> which is unsecured..


JWT -> JSON WEB TOKEN	--> hashed token , to authenticate your APIs..., from jwt.io -> you can decode your jwt..
	- generate a token using your username and password
	- in postman -> under Bearer Token put the token and hit api --> get api :: in case of all users & post api -> admin user


spring batch, jms, reactive streams and web stack..	

02/06/24 :

Spring Batch.. bulk operations at some frequent intervals..
	
	use cases : 
	          1. salary processing -> scheduled jobs -> every last working day of a month..
	          2. emp transfers from comp A to other company B -> details of emp as csv file from A's db and share this csv to B -> B stores in their db. -> exporting data from db & sharing it across (mostly in csv - coma separated value)
	          3. diff dbs -> export data from one db to other db/copy data --> migration of data.. etc

	  comp X ->  export your details as csv(excel) from their db -> share to comp Y
	  new comp Y ->  process this csv and store details of employee in their own db..      


	Any batch proj : steps :
			1. Reader     -> from csv it reads values
			2. Processor  -> do logical processing ops
			3. Writer     -> make sure data is gng to db --- writing data to db

	through our demo application ->
		1. written values into db by reading a csv file
		2. once written using listener, we read from db and printed..
			

JMS : Java Messaging Service..

ms --> communication : rest api's

msg driven -> rabbit mq, active mq, kafka, apache mq.. queue..

ms1 -> api call/msg driven -> configure our msg before ms2...

ms1 -> msg -> ms2, ms3, ms4...	

	one publisher -> one subscriber			
	one publisher -> multiple subscribers.. One to Many relationship cmnctn.

jms-sender & jms-receiver	

1 msg at a time -> queue
more than one msg -> topic..


1 - 1 ---> queue
1 -- many publishers --> topic

Full stack application overview :

spring + UI (react)

spring thymeleaf -> create a full stack app using spring boot

Thymeleaf : substitute of JSP
	Java template/framework
	html/xml/css/js/xhtml/plain text
	server side template(servlet + offline)
	fast processing
	logic -> DOM..

Thymeleaf templates can be:
	HTML (HTML5, XHTML 1.0/1.1, HTML 4)
	XML.
	TEXT (plain text)
	JAVASCRIPT (. js files)
	CSS (. css files)

classes & packages -> coded

	ctrlr -> 
		thymeleaf -> iterate over list of employees & generate a dynamic content as per the user provided template

unit testing : 

TDD / BDD

app -> each unit refers to each function. --> getEmployee or saveEmployee etc -> units..

function add(a,b){
	//logic
	//calling other functionality called summation --> we assume this works as expected(dummy data or mock object)
}

test cases :  ways of testing a functionality

	1. whole numbers
	2. negative numbers
	3. decimal numbers 
	4. rational or irrational numbers etc


	Actual vs Expected..

	actual -> the o/p of your code through junit test
	expected -> the logical expectation of your functionality..

	assertions -> equal, not equal, true, false, null, not null -> o/p of your unit functionality i.e., actual


	pom.xml -> junit depdendency/spring-boot-starter-junit/junit-jupiter-api and junit-jupiter-engine dependency

	test -> create junit tests

	test -> package (test) -> ClassNameTest

	concatenate : i/p is 2 strings -- firstName & lastName
		1. normal scenario : 2 strings & it should add the strings
		2. empty strings
		3. empty firstName
		4. empty lastName
		5. null as firstName
		6. null as lastName
		7. both null

		Steps to write a test case :

			1. initialize the req parameters to test
			2. create mock objects
			3. call the method which we are going to test
			4. assert if actual results matches with the expected results

r2dbc -> nativequery, indexed params, named params

No test cases for : application, interfaces, dto, entities.. exclusions

	Annotations : 
		
		@Test	, @BeforeAll, @BeforeEach (@Before for junit4), @AfterAll, @AfterEach,  @InjectMocks

		Repository -> @DataJpaTest, 
		@Mock, @InjectMocks, @ExtendWith(MockitoExtension.class) // to initialize your mocks
		@WebMvcTest


		sonarqube -> sonar tool for testing coverage, by edfault jacoco plugin in intellij ide to test coverage.. junits covering each and every line of code, conditions of code..


condition =>  a (&& or ||) b
   							-> a true, b true
   							-> a true, b false
   							-> a false, b false
   							-> a false, b true